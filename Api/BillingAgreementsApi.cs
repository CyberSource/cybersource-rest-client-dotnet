/* 
 * CyberSource Merged Spec
 *
 * All CyberSource API specs merged together. These are available at https://developer.cybersource.com/api/reference/api-reference.html
 *
 * OpenAPI spec version: 0.0.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using CyberSource.Client;
using CyberSource.Model;
using NLog;
using AuthenticationSdk.util;
using CyberSource.Utilities.Tracking;

namespace CyberSource.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IBillingAgreementsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Modify a Billing Agreement
        /// </summary>
        /// <remarks>
        /// #### Standing Instruction: Standing Instruction with or without Token.  #### Revoke Mandate: When you revoke a mandate, any pending direct debits linked to that mandate are canceled. No notifications are sent. When you revoke a mandate with no pending direct debits, the Bacs scheme or customer&#39;s bank notify you of any subsequent direct debit events. When you revoke a mandate, you cannot send a direct debit request using the mandate ID. Customer payments cannot be made against a revoked mandate. You can revoke a mandate when the customer:   - Requests that you revoke the mandate.   - Closes their account with you. Possible revoke mandate status values -   - Revoked—the revoke mandate request was successfully processed.   - Failed—the revoke mandate request was not accepted.  #### Update Mandate: In most cases, the account details of an existing mandate cannot be updated in the Bacs schema, except by creating a new mandate. However, some very limited customer information, like name and address, can be updated to the mandate without needing to revoke it first  #### Mandate Status: After the customer signs the mandate, request that the mandate status service verify the mandate status. Possible mandate status values:   - Active—the mandate is successfully created. A direct debit can be sent for this mandate ID.   - Pending—a pending mandate means the mandate is not yet signed.   - Failed—the customer did not authenticate.   - Expired—the deadline to create the mandate passed.   - Revoked—the mandate is cancelled.  #### Paypal Billing Agreement:  A billing agreement is set up between PayPal and your customer. When you collect the details of a customer&#39;s billing agreement, you are able to bill that customer without requiring an authorization for each payment.  You can bill the customer at the same time you process their PayPal Express checkout order, which simplifies your business processes. 
        /// </remarks>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="modifyBillingAgreement"></param>
        /// <param name="id">ID for de-registration or cancellation of Billing Agreement</param>
        /// <returns>PtsV2ModifyBillingAgreementPost201Response</returns>
        PtsV2ModifyBillingAgreementPost201Response BillingAgreementsDeRegistration (ModifyBillingAgreement modifyBillingAgreement, string id);

        /// <summary>
        /// Modify a Billing Agreement
        /// </summary>
        /// <remarks>
        /// #### Standing Instruction: Standing Instruction with or without Token.  #### Revoke Mandate: When you revoke a mandate, any pending direct debits linked to that mandate are canceled. No notifications are sent. When you revoke a mandate with no pending direct debits, the Bacs scheme or customer&#39;s bank notify you of any subsequent direct debit events. When you revoke a mandate, you cannot send a direct debit request using the mandate ID. Customer payments cannot be made against a revoked mandate. You can revoke a mandate when the customer:   - Requests that you revoke the mandate.   - Closes their account with you. Possible revoke mandate status values -   - Revoked—the revoke mandate request was successfully processed.   - Failed—the revoke mandate request was not accepted.  #### Update Mandate: In most cases, the account details of an existing mandate cannot be updated in the Bacs schema, except by creating a new mandate. However, some very limited customer information, like name and address, can be updated to the mandate without needing to revoke it first  #### Mandate Status: After the customer signs the mandate, request that the mandate status service verify the mandate status. Possible mandate status values:   - Active—the mandate is successfully created. A direct debit can be sent for this mandate ID.   - Pending—a pending mandate means the mandate is not yet signed.   - Failed—the customer did not authenticate.   - Expired—the deadline to create the mandate passed.   - Revoked—the mandate is cancelled.  #### Paypal Billing Agreement:  A billing agreement is set up between PayPal and your customer. When you collect the details of a customer&#39;s billing agreement, you are able to bill that customer without requiring an authorization for each payment.  You can bill the customer at the same time you process their PayPal Express checkout order, which simplifies your business processes. 
        /// </remarks>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="modifyBillingAgreement"></param>
        /// <param name="id">ID for de-registration or cancellation of Billing Agreement</param>
        /// <returns>ApiResponse of PtsV2ModifyBillingAgreementPost201Response</returns>
        ApiResponse<PtsV2ModifyBillingAgreementPost201Response> BillingAgreementsDeRegistrationWithHttpInfo (ModifyBillingAgreement modifyBillingAgreement, string id);
        /// <summary>
        /// Standing Instruction intimation
        /// </summary>
        /// <remarks>
        /// Standing Instruction with or without Token.
        /// </remarks>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="intimateBillingAgreement"></param>
        /// <param name="id">ID for intimation of Billing Agreement</param>
        /// <returns>PtsV2CreditsPost201Response1</returns>
        PtsV2CreditsPost201Response1 BillingAgreementsIntimation (IntimateBillingAgreement intimateBillingAgreement, string id);

        /// <summary>
        /// Standing Instruction intimation
        /// </summary>
        /// <remarks>
        /// Standing Instruction with or without Token.
        /// </remarks>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="intimateBillingAgreement"></param>
        /// <param name="id">ID for intimation of Billing Agreement</param>
        /// <returns>ApiResponse of PtsV2CreditsPost201Response1</returns>
        ApiResponse<PtsV2CreditsPost201Response1> BillingAgreementsIntimationWithHttpInfo (IntimateBillingAgreement intimateBillingAgreement, string id);
        /// <summary>
        /// Create a Billing Agreement
        /// </summary>
        /// <remarks>
        /// #### Standing Instruction: Standing Instruction with or without Token. Transaction amount in case First payment is coming along with registration. Only 2 decimal places allowed  #### Create Mandate: You can create a mandate through the direct debit mandate flow. Possible create mandate status values:   - Pending—the create mandate request was successfully processed.   - Failed—the create mandate request was not accepted.  #### Import Mandate: In the Bacs scheme, a mandate is created with a status of active. Direct debit collections can be made against it immediately. You can import a mandate to the CyberSource database when:   - You have existing customers with signed, active mandates   - You manage mandates outside of CyberSource.  When you import an existing mandate to the CyberSource database, provide a unique value for the mandate ID or the request results in an error. If an import mandate request is not accepted, the import mandate status value is failed. 
        /// </remarks>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createBillingAgreement"></param>
        /// <returns>PtsV2CreateBillingAgreementPost201Response</returns>
        PtsV2CreateBillingAgreementPost201Response BillingAgreementsRegistration (CreateBillingAgreement createBillingAgreement);

        /// <summary>
        /// Create a Billing Agreement
        /// </summary>
        /// <remarks>
        /// #### Standing Instruction: Standing Instruction with or without Token. Transaction amount in case First payment is coming along with registration. Only 2 decimal places allowed  #### Create Mandate: You can create a mandate through the direct debit mandate flow. Possible create mandate status values:   - Pending—the create mandate request was successfully processed.   - Failed—the create mandate request was not accepted.  #### Import Mandate: In the Bacs scheme, a mandate is created with a status of active. Direct debit collections can be made against it immediately. You can import a mandate to the CyberSource database when:   - You have existing customers with signed, active mandates   - You manage mandates outside of CyberSource.  When you import an existing mandate to the CyberSource database, provide a unique value for the mandate ID or the request results in an error. If an import mandate request is not accepted, the import mandate status value is failed. 
        /// </remarks>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createBillingAgreement"></param>
        /// <returns>ApiResponse of PtsV2CreateBillingAgreementPost201Response</returns>
        ApiResponse<PtsV2CreateBillingAgreementPost201Response> BillingAgreementsRegistrationWithHttpInfo (CreateBillingAgreement createBillingAgreement);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Modify a Billing Agreement
        /// </summary>
        /// <remarks>
        /// #### Standing Instruction: Standing Instruction with or without Token.  #### Revoke Mandate: When you revoke a mandate, any pending direct debits linked to that mandate are canceled. No notifications are sent. When you revoke a mandate with no pending direct debits, the Bacs scheme or customer&#39;s bank notify you of any subsequent direct debit events. When you revoke a mandate, you cannot send a direct debit request using the mandate ID. Customer payments cannot be made against a revoked mandate. You can revoke a mandate when the customer:   - Requests that you revoke the mandate.   - Closes their account with you. Possible revoke mandate status values -   - Revoked—the revoke mandate request was successfully processed.   - Failed—the revoke mandate request was not accepted.  #### Update Mandate: In most cases, the account details of an existing mandate cannot be updated in the Bacs schema, except by creating a new mandate. However, some very limited customer information, like name and address, can be updated to the mandate without needing to revoke it first  #### Mandate Status: After the customer signs the mandate, request that the mandate status service verify the mandate status. Possible mandate status values:   - Active—the mandate is successfully created. A direct debit can be sent for this mandate ID.   - Pending—a pending mandate means the mandate is not yet signed.   - Failed—the customer did not authenticate.   - Expired—the deadline to create the mandate passed.   - Revoked—the mandate is cancelled.  #### Paypal Billing Agreement:  A billing agreement is set up between PayPal and your customer. When you collect the details of a customer&#39;s billing agreement, you are able to bill that customer without requiring an authorization for each payment.  You can bill the customer at the same time you process their PayPal Express checkout order, which simplifies your business processes. 
        /// </remarks>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="modifyBillingAgreement"></param>
        /// <param name="id">ID for de-registration or cancellation of Billing Agreement</param>
        /// <returns>Task of PtsV2ModifyBillingAgreementPost201Response</returns>
        System.Threading.Tasks.Task<PtsV2ModifyBillingAgreementPost201Response> BillingAgreementsDeRegistrationAsync (ModifyBillingAgreement modifyBillingAgreement, string id);

        /// <summary>
        /// Modify a Billing Agreement
        /// </summary>
        /// <remarks>
        /// #### Standing Instruction: Standing Instruction with or without Token.  #### Revoke Mandate: When you revoke a mandate, any pending direct debits linked to that mandate are canceled. No notifications are sent. When you revoke a mandate with no pending direct debits, the Bacs scheme or customer&#39;s bank notify you of any subsequent direct debit events. When you revoke a mandate, you cannot send a direct debit request using the mandate ID. Customer payments cannot be made against a revoked mandate. You can revoke a mandate when the customer:   - Requests that you revoke the mandate.   - Closes their account with you. Possible revoke mandate status values -   - Revoked—the revoke mandate request was successfully processed.   - Failed—the revoke mandate request was not accepted.  #### Update Mandate: In most cases, the account details of an existing mandate cannot be updated in the Bacs schema, except by creating a new mandate. However, some very limited customer information, like name and address, can be updated to the mandate without needing to revoke it first  #### Mandate Status: After the customer signs the mandate, request that the mandate status service verify the mandate status. Possible mandate status values:   - Active—the mandate is successfully created. A direct debit can be sent for this mandate ID.   - Pending—a pending mandate means the mandate is not yet signed.   - Failed—the customer did not authenticate.   - Expired—the deadline to create the mandate passed.   - Revoked—the mandate is cancelled.  #### Paypal Billing Agreement:  A billing agreement is set up between PayPal and your customer. When you collect the details of a customer&#39;s billing agreement, you are able to bill that customer without requiring an authorization for each payment.  You can bill the customer at the same time you process their PayPal Express checkout order, which simplifies your business processes. 
        /// </remarks>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="modifyBillingAgreement"></param>
        /// <param name="id">ID for de-registration or cancellation of Billing Agreement</param>
        /// <returns>Task of ApiResponse (PtsV2ModifyBillingAgreementPost201Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<PtsV2ModifyBillingAgreementPost201Response>> BillingAgreementsDeRegistrationAsyncWithHttpInfo (ModifyBillingAgreement modifyBillingAgreement, string id);
        /// <summary>
        /// Standing Instruction intimation
        /// </summary>
        /// <remarks>
        /// Standing Instruction with or without Token.
        /// </remarks>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="intimateBillingAgreement"></param>
        /// <param name="id">ID for intimation of Billing Agreement</param>
        /// <returns>Task of PtsV2CreditsPost201Response1</returns>
        System.Threading.Tasks.Task<PtsV2CreditsPost201Response1> BillingAgreementsIntimationAsync (IntimateBillingAgreement intimateBillingAgreement, string id);

        /// <summary>
        /// Standing Instruction intimation
        /// </summary>
        /// <remarks>
        /// Standing Instruction with or without Token.
        /// </remarks>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="intimateBillingAgreement"></param>
        /// <param name="id">ID for intimation of Billing Agreement</param>
        /// <returns>Task of ApiResponse (PtsV2CreditsPost201Response1)</returns>
        System.Threading.Tasks.Task<ApiResponse<PtsV2CreditsPost201Response1>> BillingAgreementsIntimationAsyncWithHttpInfo (IntimateBillingAgreement intimateBillingAgreement, string id);
        /// <summary>
        /// Create a Billing Agreement
        /// </summary>
        /// <remarks>
        /// #### Standing Instruction: Standing Instruction with or without Token. Transaction amount in case First payment is coming along with registration. Only 2 decimal places allowed  #### Create Mandate: You can create a mandate through the direct debit mandate flow. Possible create mandate status values:   - Pending—the create mandate request was successfully processed.   - Failed—the create mandate request was not accepted.  #### Import Mandate: In the Bacs scheme, a mandate is created with a status of active. Direct debit collections can be made against it immediately. You can import a mandate to the CyberSource database when:   - You have existing customers with signed, active mandates   - You manage mandates outside of CyberSource.  When you import an existing mandate to the CyberSource database, provide a unique value for the mandate ID or the request results in an error. If an import mandate request is not accepted, the import mandate status value is failed. 
        /// </remarks>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createBillingAgreement"></param>
        /// <returns>Task of PtsV2CreateBillingAgreementPost201Response</returns>
        System.Threading.Tasks.Task<PtsV2CreateBillingAgreementPost201Response> BillingAgreementsRegistrationAsync (CreateBillingAgreement createBillingAgreement);

        /// <summary>
        /// Create a Billing Agreement
        /// </summary>
        /// <remarks>
        /// #### Standing Instruction: Standing Instruction with or without Token. Transaction amount in case First payment is coming along with registration. Only 2 decimal places allowed  #### Create Mandate: You can create a mandate through the direct debit mandate flow. Possible create mandate status values:   - Pending—the create mandate request was successfully processed.   - Failed—the create mandate request was not accepted.  #### Import Mandate: In the Bacs scheme, a mandate is created with a status of active. Direct debit collections can be made against it immediately. You can import a mandate to the CyberSource database when:   - You have existing customers with signed, active mandates   - You manage mandates outside of CyberSource.  When you import an existing mandate to the CyberSource database, provide a unique value for the mandate ID or the request results in an error. If an import mandate request is not accepted, the import mandate status value is failed. 
        /// </remarks>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createBillingAgreement"></param>
        /// <returns>Task of ApiResponse (PtsV2CreateBillingAgreementPost201Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<PtsV2CreateBillingAgreementPost201Response>> BillingAgreementsRegistrationAsyncWithHttpInfo (CreateBillingAgreement createBillingAgreement);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class BillingAgreementsApi : IBillingAgreementsApi
    {
        private static Logger logger;
        private ExceptionFactory _exceptionFactory = (name, response) => null;
        private int? _statusCode;

        /// <summary>
        /// Initializes a new instance of the <see cref="BillingAgreementsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public BillingAgreementsApi(string basePath)
        {
            Configuration = new Configuration(new ApiClient(basePath));

            ExceptionFactory = Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                Configuration.ApiClient.Configuration = Configuration;
            }

            if (logger == null)
            {
                logger = LogManager.GetCurrentClassLogger();
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="BillingAgreementsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public BillingAgreementsApi(Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                Configuration = Configuration.Default;
            else
                Configuration = configuration;

            ExceptionFactory = Configuration.DefaultExceptionFactory;

            Configuration.ApiClient.Configuration = Configuration;

            if (logger == null)
            {
                logger = LogManager.GetCurrentClassLogger();
            }
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return Configuration.ApiClient.RestClient.Options.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(string basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Configuration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    logger.Error("InvalidOperationException : Multicast delegate for ExceptionFactory is unsupported.");
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public Dictionary<string, string> DefaultHeader()
        {
            return Configuration.DefaultHeader;
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Retrieves the status code being set for the most recently executed API request.
        /// </summary>
        /// <returns>Status Code of previous request</returns>
        public int GetStatusCode()
        {
            return this._statusCode == null ? 0 : (int) this._statusCode;
        }

        /// <summary>
        /// Sets the value of status code for the most recently executed API request, in order to be retrieved later.
        /// </summary>
        /// <param name="statusCode">Status Code to be set</param>
        /// <returns></returns>
        public void SetStatusCode(int? statusCode)
        {
            this._statusCode = statusCode;
        }

        /// <summary>
        /// Modify a Billing Agreement #### Standing Instruction: Standing Instruction with or without Token.  #### Revoke Mandate: When you revoke a mandate, any pending direct debits linked to that mandate are canceled. No notifications are sent. When you revoke a mandate with no pending direct debits, the Bacs scheme or customer&#39;s bank notify you of any subsequent direct debit events. When you revoke a mandate, you cannot send a direct debit request using the mandate ID. Customer payments cannot be made against a revoked mandate. You can revoke a mandate when the customer:   - Requests that you revoke the mandate.   - Closes their account with you. Possible revoke mandate status values -   - Revoked—the revoke mandate request was successfully processed.   - Failed—the revoke mandate request was not accepted.  #### Update Mandate: In most cases, the account details of an existing mandate cannot be updated in the Bacs schema, except by creating a new mandate. However, some very limited customer information, like name and address, can be updated to the mandate without needing to revoke it first  #### Mandate Status: After the customer signs the mandate, request that the mandate status service verify the mandate status. Possible mandate status values:   - Active—the mandate is successfully created. A direct debit can be sent for this mandate ID.   - Pending—a pending mandate means the mandate is not yet signed.   - Failed—the customer did not authenticate.   - Expired—the deadline to create the mandate passed.   - Revoked—the mandate is cancelled.  #### Paypal Billing Agreement:  A billing agreement is set up between PayPal and your customer. When you collect the details of a customer&#39;s billing agreement, you are able to bill that customer without requiring an authorization for each payment.  You can bill the customer at the same time you process their PayPal Express checkout order, which simplifies your business processes. 
        /// </summary>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="modifyBillingAgreement"></param>
        /// <param name="id">ID for de-registration or cancellation of Billing Agreement</param>
        /// <returns>PtsV2ModifyBillingAgreementPost201Response</returns>
        public PtsV2ModifyBillingAgreementPost201Response BillingAgreementsDeRegistration (ModifyBillingAgreement modifyBillingAgreement, string id)
        {
            logger.Debug("CALLING API \"BillingAgreementsDeRegistration\" STARTED");
            this.SetStatusCode(null);
            ApiResponse<PtsV2ModifyBillingAgreementPost201Response> localVarResponse = BillingAgreementsDeRegistrationWithHttpInfo(modifyBillingAgreement, id);
            logger.Debug("CALLING API \"BillingAgreementsDeRegistration\" ENDED");
            this.SetStatusCode(localVarResponse.StatusCode);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Modify a Billing Agreement #### Standing Instruction: Standing Instruction with or without Token.  #### Revoke Mandate: When you revoke a mandate, any pending direct debits linked to that mandate are canceled. No notifications are sent. When you revoke a mandate with no pending direct debits, the Bacs scheme or customer&#39;s bank notify you of any subsequent direct debit events. When you revoke a mandate, you cannot send a direct debit request using the mandate ID. Customer payments cannot be made against a revoked mandate. You can revoke a mandate when the customer:   - Requests that you revoke the mandate.   - Closes their account with you. Possible revoke mandate status values -   - Revoked—the revoke mandate request was successfully processed.   - Failed—the revoke mandate request was not accepted.  #### Update Mandate: In most cases, the account details of an existing mandate cannot be updated in the Bacs schema, except by creating a new mandate. However, some very limited customer information, like name and address, can be updated to the mandate without needing to revoke it first  #### Mandate Status: After the customer signs the mandate, request that the mandate status service verify the mandate status. Possible mandate status values:   - Active—the mandate is successfully created. A direct debit can be sent for this mandate ID.   - Pending—a pending mandate means the mandate is not yet signed.   - Failed—the customer did not authenticate.   - Expired—the deadline to create the mandate passed.   - Revoked—the mandate is cancelled.  #### Paypal Billing Agreement:  A billing agreement is set up between PayPal and your customer. When you collect the details of a customer&#39;s billing agreement, you are able to bill that customer without requiring an authorization for each payment.  You can bill the customer at the same time you process their PayPal Express checkout order, which simplifies your business processes. 
        /// </summary>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="modifyBillingAgreement"></param>
        /// <param name="id">ID for de-registration or cancellation of Billing Agreement</param>
        /// <returns>ApiResponse of PtsV2ModifyBillingAgreementPost201Response</returns>
        public ApiResponse< PtsV2ModifyBillingAgreementPost201Response > BillingAgreementsDeRegistrationWithHttpInfo (ModifyBillingAgreement modifyBillingAgreement, string id)
        {
            LogUtility logUtility = new LogUtility();

            // verify the required parameter 'modifyBillingAgreement' is set
            if (modifyBillingAgreement == null)
            {
                logger.Error("ApiException : Missing required parameter 'modifyBillingAgreement' when calling BillingAgreementsApi->BillingAgreementsDeRegistration");
                throw new ApiException(400, "Missing required parameter 'modifyBillingAgreement' when calling BillingAgreementsApi->BillingAgreementsDeRegistration");
            }
            // verify the required parameter 'id' is set
            if (id == null)
            {
                logger.Error("ApiException : Missing required parameter 'id' when calling BillingAgreementsApi->BillingAgreementsDeRegistration");
                throw new ApiException(400, "Missing required parameter 'id' when calling BillingAgreementsApi->BillingAgreementsDeRegistration");
            }

            var localVarPath = $"/pts/v2/billing-agreements/{id}";
            var localVarPathParams = new Dictionary<string, string>();
            var localVarQueryParams = new Dictionary<string, string>();
            var localVarHeaderParams = new Dictionary<string, string>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<string, string>();
            var localVarFileParams = new Dictionary<string, FileParameter>();
            object localVarPostBody = null;

            // to determine the Content-Type header
            string[] localVarHttpContentTypes = new string[] {
                "application/json;charset=utf-8"
            };
            string localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            string[] localVarHttpHeaderAccepts = new string[] {
                "application/hal+json;charset=utf-8"
            };
            string localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
            {
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);
            }

            if (id != null)
            {
                localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            }
            logger.Debug($"HTTP Request Body :\n{logUtility.ConvertDictionaryToString(localVarPathParams)}");
            if (modifyBillingAgreement != null && modifyBillingAgreement.GetType() != typeof(byte[]))
            {
                SdkTracker sdkTracker = new SdkTracker();
                modifyBillingAgreement = (ModifyBillingAgreement)sdkTracker.InsertDeveloperIdTracker(modifyBillingAgreement, modifyBillingAgreement.GetType().Name, Configuration.ApiClient.Configuration.MerchantConfigDictionaryObj["runEnvironment"]);
                localVarPostBody = Configuration.ApiClient.Serialize(modifyBillingAgreement); // http body (model) parameter
            }
            else
            {
                localVarPostBody = modifyBillingAgreement; // byte array
            }

            if (logUtility.IsMaskingEnabled(logger))
            {
                logger.Debug($"HTTP Request Body :\n{logUtility.MaskSensitiveData(localVarPostBody.ToString())}");
            }
            else
            {
                logger.Debug($"HTTP Request Body :\n{localVarPostBody}");
            }


            // make the HTTP request
            RestResponse localVarResponse = (RestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.Patch, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("BillingAgreementsDeRegistration", localVarResponse);
                if (exception != null)
                {
                    logger.Error($"Exception : {exception.Message}");
                    throw exception;
                }
            }

            return new ApiResponse<PtsV2ModifyBillingAgreementPost201Response>(localVarStatusCode,
                localVarResponse.Headers.GroupBy(h => h.Name).ToDictionary(x => x.Key, x => string.Join(", ", x.Select(h => h.Value.ToString()))),
                (PtsV2ModifyBillingAgreementPost201Response) Configuration.ApiClient.Deserialize(localVarResponse, typeof(PtsV2ModifyBillingAgreementPost201Response))); // Return statement
        }

        /// <summary>
        /// Modify a Billing Agreement #### Standing Instruction: Standing Instruction with or without Token.  #### Revoke Mandate: When you revoke a mandate, any pending direct debits linked to that mandate are canceled. No notifications are sent. When you revoke a mandate with no pending direct debits, the Bacs scheme or customer&#39;s bank notify you of any subsequent direct debit events. When you revoke a mandate, you cannot send a direct debit request using the mandate ID. Customer payments cannot be made against a revoked mandate. You can revoke a mandate when the customer:   - Requests that you revoke the mandate.   - Closes their account with you. Possible revoke mandate status values -   - Revoked—the revoke mandate request was successfully processed.   - Failed—the revoke mandate request was not accepted.  #### Update Mandate: In most cases, the account details of an existing mandate cannot be updated in the Bacs schema, except by creating a new mandate. However, some very limited customer information, like name and address, can be updated to the mandate without needing to revoke it first  #### Mandate Status: After the customer signs the mandate, request that the mandate status service verify the mandate status. Possible mandate status values:   - Active—the mandate is successfully created. A direct debit can be sent for this mandate ID.   - Pending—a pending mandate means the mandate is not yet signed.   - Failed—the customer did not authenticate.   - Expired—the deadline to create the mandate passed.   - Revoked—the mandate is cancelled.  #### Paypal Billing Agreement:  A billing agreement is set up between PayPal and your customer. When you collect the details of a customer&#39;s billing agreement, you are able to bill that customer without requiring an authorization for each payment.  You can bill the customer at the same time you process their PayPal Express checkout order, which simplifies your business processes. 
        /// </summary>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="modifyBillingAgreement"></param>
        /// <param name="id">ID for de-registration or cancellation of Billing Agreement</param>
        /// <returns>Task of PtsV2ModifyBillingAgreementPost201Response</returns>
        public async System.Threading.Tasks.Task<PtsV2ModifyBillingAgreementPost201Response> BillingAgreementsDeRegistrationAsync (ModifyBillingAgreement modifyBillingAgreement, string id)
        {
            logger.Debug("CALLING API \"BillingAgreementsDeRegistrationAsync\" STARTED");
            this.SetStatusCode(null);
            ApiResponse<PtsV2ModifyBillingAgreementPost201Response> localVarResponse = await BillingAgreementsDeRegistrationAsyncWithHttpInfo(modifyBillingAgreement, id);
            logger.Debug("CALLING API \"BillingAgreementsDeRegistrationAsync\" ENDED");
            this.SetStatusCode(localVarResponse.StatusCode);
            return localVarResponse.Data;

        }

        /// <summary>
        /// Modify a Billing Agreement #### Standing Instruction: Standing Instruction with or without Token.  #### Revoke Mandate: When you revoke a mandate, any pending direct debits linked to that mandate are canceled. No notifications are sent. When you revoke a mandate with no pending direct debits, the Bacs scheme or customer&#39;s bank notify you of any subsequent direct debit events. When you revoke a mandate, you cannot send a direct debit request using the mandate ID. Customer payments cannot be made against a revoked mandate. You can revoke a mandate when the customer:   - Requests that you revoke the mandate.   - Closes their account with you. Possible revoke mandate status values -   - Revoked—the revoke mandate request was successfully processed.   - Failed—the revoke mandate request was not accepted.  #### Update Mandate: In most cases, the account details of an existing mandate cannot be updated in the Bacs schema, except by creating a new mandate. However, some very limited customer information, like name and address, can be updated to the mandate without needing to revoke it first  #### Mandate Status: After the customer signs the mandate, request that the mandate status service verify the mandate status. Possible mandate status values:   - Active—the mandate is successfully created. A direct debit can be sent for this mandate ID.   - Pending—a pending mandate means the mandate is not yet signed.   - Failed—the customer did not authenticate.   - Expired—the deadline to create the mandate passed.   - Revoked—the mandate is cancelled.  #### Paypal Billing Agreement:  A billing agreement is set up between PayPal and your customer. When you collect the details of a customer&#39;s billing agreement, you are able to bill that customer without requiring an authorization for each payment.  You can bill the customer at the same time you process their PayPal Express checkout order, which simplifies your business processes. 
        /// </summary>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="modifyBillingAgreement"></param>
        /// <param name="id">ID for de-registration or cancellation of Billing Agreement</param>
        /// <returns>Task of ApiResponse (PtsV2ModifyBillingAgreementPost201Response)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PtsV2ModifyBillingAgreementPost201Response>> BillingAgreementsDeRegistrationAsyncWithHttpInfo (ModifyBillingAgreement modifyBillingAgreement, string id)
        {
            LogUtility logUtility = new LogUtility();

            // verify the required parameter 'modifyBillingAgreement' is set
            if (modifyBillingAgreement == null)
            {
                logger.Error("ApiException : Missing required parameter 'modifyBillingAgreement' when calling BillingAgreementsApi->BillingAgreementsDeRegistration");
                throw new ApiException(400, "Missing required parameter 'modifyBillingAgreement' when calling BillingAgreementsApi->BillingAgreementsDeRegistration");
            }
            // verify the required parameter 'id' is set
            if (id == null)
            {
                logger.Error("ApiException : Missing required parameter 'id' when calling BillingAgreementsApi->BillingAgreementsDeRegistration");
                throw new ApiException(400, "Missing required parameter 'id' when calling BillingAgreementsApi->BillingAgreementsDeRegistration");
            }

            var localVarPath = $"/pts/v2/billing-agreements/{id}";
            var localVarPathParams = new Dictionary<string, string>();
            var localVarQueryParams = new Dictionary<string, string>();
            var localVarHeaderParams = new Dictionary<string, string>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<string, string>();
            var localVarFileParams = new Dictionary<string, FileParameter>();
            object localVarPostBody = null;

            // to determine the Content-Type header
            string[] localVarHttpContentTypes = new string[] {
                "application/json;charset=utf-8"
            };
            string localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            string[] localVarHttpHeaderAccepts = new string[] {
                "application/hal+json;charset=utf-8"
            };
            string localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
            {
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);
            }

            if (id != null)
            {
                localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            }
            logger.Debug($"HTTP Request Body :\n{logUtility.ConvertDictionaryToString(localVarPathParams)}");
            if (modifyBillingAgreement != null && modifyBillingAgreement.GetType() != typeof(byte[]))
            {
                SdkTracker sdkTracker = new SdkTracker();
                modifyBillingAgreement = (ModifyBillingAgreement)sdkTracker.InsertDeveloperIdTracker(modifyBillingAgreement, modifyBillingAgreement.GetType().Name, Configuration.ApiClient.Configuration.MerchantConfigDictionaryObj["runEnvironment"]);
                localVarPostBody = Configuration.ApiClient.Serialize(modifyBillingAgreement); // http body (model) parameter
            }
            else
            {
                localVarPostBody = modifyBillingAgreement; // byte array
            }

            if (logUtility.IsMaskingEnabled(logger))
            {
                logger.Debug($"HTTP Request Body :\n{logUtility.MaskSensitiveData(localVarPostBody.ToString())}");
            }
            else
            {
                logger.Debug($"HTTP Request Body :\n{localVarPostBody}");
            }


            // make the HTTP request
            RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.Patch, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int)localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("BillingAgreementsDeRegistration", localVarResponse);
                if (exception != null)
                {
                    logger.Error($"Exception : {exception.Message}");
                    throw exception;
                }
            }

            return new ApiResponse<PtsV2ModifyBillingAgreementPost201Response>(localVarStatusCode,
                localVarResponse.Headers.GroupBy(h => h.Name).ToDictionary(x => x.Key, x => string.Join(", ", x.Select(h => h.Value.ToString()))),
                (PtsV2ModifyBillingAgreementPost201Response) Configuration.ApiClient.Deserialize(localVarResponse, typeof(PtsV2ModifyBillingAgreementPost201Response))); // Return statement
        }
        /// <summary>
        /// Standing Instruction intimation Standing Instruction with or without Token.
        /// </summary>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="intimateBillingAgreement"></param>
        /// <param name="id">ID for intimation of Billing Agreement</param>
        /// <returns>PtsV2CreditsPost201Response1</returns>
        public PtsV2CreditsPost201Response1 BillingAgreementsIntimation (IntimateBillingAgreement intimateBillingAgreement, string id)
        {
            logger.Debug("CALLING API \"BillingAgreementsIntimation\" STARTED");
            this.SetStatusCode(null);
            ApiResponse<PtsV2CreditsPost201Response1> localVarResponse = BillingAgreementsIntimationWithHttpInfo(intimateBillingAgreement, id);
            logger.Debug("CALLING API \"BillingAgreementsIntimation\" ENDED");
            this.SetStatusCode(localVarResponse.StatusCode);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Standing Instruction intimation Standing Instruction with or without Token.
        /// </summary>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="intimateBillingAgreement"></param>
        /// <param name="id">ID for intimation of Billing Agreement</param>
        /// <returns>ApiResponse of PtsV2CreditsPost201Response1</returns>
        public ApiResponse< PtsV2CreditsPost201Response1 > BillingAgreementsIntimationWithHttpInfo (IntimateBillingAgreement intimateBillingAgreement, string id)
        {
            LogUtility logUtility = new LogUtility();

            // verify the required parameter 'intimateBillingAgreement' is set
            if (intimateBillingAgreement == null)
            {
                logger.Error("ApiException : Missing required parameter 'intimateBillingAgreement' when calling BillingAgreementsApi->BillingAgreementsIntimation");
                throw new ApiException(400, "Missing required parameter 'intimateBillingAgreement' when calling BillingAgreementsApi->BillingAgreementsIntimation");
            }
            // verify the required parameter 'id' is set
            if (id == null)
            {
                logger.Error("ApiException : Missing required parameter 'id' when calling BillingAgreementsApi->BillingAgreementsIntimation");
                throw new ApiException(400, "Missing required parameter 'id' when calling BillingAgreementsApi->BillingAgreementsIntimation");
            }

            var localVarPath = $"/pts/v2/billing-agreements/{id}/intimations";
            var localVarPathParams = new Dictionary<string, string>();
            var localVarQueryParams = new Dictionary<string, string>();
            var localVarHeaderParams = new Dictionary<string, string>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<string, string>();
            var localVarFileParams = new Dictionary<string, FileParameter>();
            object localVarPostBody = null;

            // to determine the Content-Type header
            string[] localVarHttpContentTypes = new string[] {
                "application/json;charset=utf-8"
            };
            string localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            string[] localVarHttpHeaderAccepts = new string[] {
                "application/hal+json;charset=utf-8"
            };
            string localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
            {
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);
            }

            if (id != null)
            {
                localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            }
            logger.Debug($"HTTP Request Body :\n{logUtility.ConvertDictionaryToString(localVarPathParams)}");
            if (intimateBillingAgreement != null && intimateBillingAgreement.GetType() != typeof(byte[]))
            {
                SdkTracker sdkTracker = new SdkTracker();
                intimateBillingAgreement = (IntimateBillingAgreement)sdkTracker.InsertDeveloperIdTracker(intimateBillingAgreement, intimateBillingAgreement.GetType().Name, Configuration.ApiClient.Configuration.MerchantConfigDictionaryObj["runEnvironment"]);
                localVarPostBody = Configuration.ApiClient.Serialize(intimateBillingAgreement); // http body (model) parameter
            }
            else
            {
                localVarPostBody = intimateBillingAgreement; // byte array
            }

            if (logUtility.IsMaskingEnabled(logger))
            {
                logger.Debug($"HTTP Request Body :\n{logUtility.MaskSensitiveData(localVarPostBody.ToString())}");
            }
            else
            {
                logger.Debug($"HTTP Request Body :\n{localVarPostBody}");
            }


            // make the HTTP request
            RestResponse localVarResponse = (RestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.Post, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("BillingAgreementsIntimation", localVarResponse);
                if (exception != null)
                {
                    logger.Error($"Exception : {exception.Message}");
                    throw exception;
                }
            }

            return new ApiResponse<PtsV2CreditsPost201Response1>(localVarStatusCode,
                localVarResponse.Headers.GroupBy(h => h.Name).ToDictionary(x => x.Key, x => string.Join(", ", x.Select(h => h.Value.ToString()))),
                (PtsV2CreditsPost201Response1) Configuration.ApiClient.Deserialize(localVarResponse, typeof(PtsV2CreditsPost201Response1))); // Return statement
        }

        /// <summary>
        /// Standing Instruction intimation Standing Instruction with or without Token.
        /// </summary>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="intimateBillingAgreement"></param>
        /// <param name="id">ID for intimation of Billing Agreement</param>
        /// <returns>Task of PtsV2CreditsPost201Response1</returns>
        public async System.Threading.Tasks.Task<PtsV2CreditsPost201Response1> BillingAgreementsIntimationAsync (IntimateBillingAgreement intimateBillingAgreement, string id)
        {
            logger.Debug("CALLING API \"BillingAgreementsIntimationAsync\" STARTED");
            this.SetStatusCode(null);
            ApiResponse<PtsV2CreditsPost201Response1> localVarResponse = await BillingAgreementsIntimationAsyncWithHttpInfo(intimateBillingAgreement, id);
            logger.Debug("CALLING API \"BillingAgreementsIntimationAsync\" ENDED");
            this.SetStatusCode(localVarResponse.StatusCode);
            return localVarResponse.Data;

        }

        /// <summary>
        /// Standing Instruction intimation Standing Instruction with or without Token.
        /// </summary>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="intimateBillingAgreement"></param>
        /// <param name="id">ID for intimation of Billing Agreement</param>
        /// <returns>Task of ApiResponse (PtsV2CreditsPost201Response1)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PtsV2CreditsPost201Response1>> BillingAgreementsIntimationAsyncWithHttpInfo (IntimateBillingAgreement intimateBillingAgreement, string id)
        {
            LogUtility logUtility = new LogUtility();

            // verify the required parameter 'intimateBillingAgreement' is set
            if (intimateBillingAgreement == null)
            {
                logger.Error("ApiException : Missing required parameter 'intimateBillingAgreement' when calling BillingAgreementsApi->BillingAgreementsIntimation");
                throw new ApiException(400, "Missing required parameter 'intimateBillingAgreement' when calling BillingAgreementsApi->BillingAgreementsIntimation");
            }
            // verify the required parameter 'id' is set
            if (id == null)
            {
                logger.Error("ApiException : Missing required parameter 'id' when calling BillingAgreementsApi->BillingAgreementsIntimation");
                throw new ApiException(400, "Missing required parameter 'id' when calling BillingAgreementsApi->BillingAgreementsIntimation");
            }

            var localVarPath = $"/pts/v2/billing-agreements/{id}/intimations";
            var localVarPathParams = new Dictionary<string, string>();
            var localVarQueryParams = new Dictionary<string, string>();
            var localVarHeaderParams = new Dictionary<string, string>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<string, string>();
            var localVarFileParams = new Dictionary<string, FileParameter>();
            object localVarPostBody = null;

            // to determine the Content-Type header
            string[] localVarHttpContentTypes = new string[] {
                "application/json;charset=utf-8"
            };
            string localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            string[] localVarHttpHeaderAccepts = new string[] {
                "application/hal+json;charset=utf-8"
            };
            string localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
            {
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);
            }

            if (id != null)
            {
                localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            }
            logger.Debug($"HTTP Request Body :\n{logUtility.ConvertDictionaryToString(localVarPathParams)}");
            if (intimateBillingAgreement != null && intimateBillingAgreement.GetType() != typeof(byte[]))
            {
                SdkTracker sdkTracker = new SdkTracker();
                intimateBillingAgreement = (IntimateBillingAgreement)sdkTracker.InsertDeveloperIdTracker(intimateBillingAgreement, intimateBillingAgreement.GetType().Name, Configuration.ApiClient.Configuration.MerchantConfigDictionaryObj["runEnvironment"]);
                localVarPostBody = Configuration.ApiClient.Serialize(intimateBillingAgreement); // http body (model) parameter
            }
            else
            {
                localVarPostBody = intimateBillingAgreement; // byte array
            }

            if (logUtility.IsMaskingEnabled(logger))
            {
                logger.Debug($"HTTP Request Body :\n{logUtility.MaskSensitiveData(localVarPostBody.ToString())}");
            }
            else
            {
                logger.Debug($"HTTP Request Body :\n{localVarPostBody}");
            }


            // make the HTTP request
            RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.Post, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int)localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("BillingAgreementsIntimation", localVarResponse);
                if (exception != null)
                {
                    logger.Error($"Exception : {exception.Message}");
                    throw exception;
                }
            }

            return new ApiResponse<PtsV2CreditsPost201Response1>(localVarStatusCode,
                localVarResponse.Headers.GroupBy(h => h.Name).ToDictionary(x => x.Key, x => string.Join(", ", x.Select(h => h.Value.ToString()))),
                (PtsV2CreditsPost201Response1) Configuration.ApiClient.Deserialize(localVarResponse, typeof(PtsV2CreditsPost201Response1))); // Return statement
        }
        /// <summary>
        /// Create a Billing Agreement #### Standing Instruction: Standing Instruction with or without Token. Transaction amount in case First payment is coming along with registration. Only 2 decimal places allowed  #### Create Mandate: You can create a mandate through the direct debit mandate flow. Possible create mandate status values:   - Pending—the create mandate request was successfully processed.   - Failed—the create mandate request was not accepted.  #### Import Mandate: In the Bacs scheme, a mandate is created with a status of active. Direct debit collections can be made against it immediately. You can import a mandate to the CyberSource database when:   - You have existing customers with signed, active mandates   - You manage mandates outside of CyberSource.  When you import an existing mandate to the CyberSource database, provide a unique value for the mandate ID or the request results in an error. If an import mandate request is not accepted, the import mandate status value is failed. 
        /// </summary>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createBillingAgreement"></param>
        /// <returns>PtsV2CreateBillingAgreementPost201Response</returns>
        public PtsV2CreateBillingAgreementPost201Response BillingAgreementsRegistration (CreateBillingAgreement createBillingAgreement)
        {
            logger.Debug("CALLING API \"BillingAgreementsRegistration\" STARTED");
            this.SetStatusCode(null);
            ApiResponse<PtsV2CreateBillingAgreementPost201Response> localVarResponse = BillingAgreementsRegistrationWithHttpInfo(createBillingAgreement);
            logger.Debug("CALLING API \"BillingAgreementsRegistration\" ENDED");
            this.SetStatusCode(localVarResponse.StatusCode);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create a Billing Agreement #### Standing Instruction: Standing Instruction with or without Token. Transaction amount in case First payment is coming along with registration. Only 2 decimal places allowed  #### Create Mandate: You can create a mandate through the direct debit mandate flow. Possible create mandate status values:   - Pending—the create mandate request was successfully processed.   - Failed—the create mandate request was not accepted.  #### Import Mandate: In the Bacs scheme, a mandate is created with a status of active. Direct debit collections can be made against it immediately. You can import a mandate to the CyberSource database when:   - You have existing customers with signed, active mandates   - You manage mandates outside of CyberSource.  When you import an existing mandate to the CyberSource database, provide a unique value for the mandate ID or the request results in an error. If an import mandate request is not accepted, the import mandate status value is failed. 
        /// </summary>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createBillingAgreement"></param>
        /// <returns>ApiResponse of PtsV2CreateBillingAgreementPost201Response</returns>
        public ApiResponse< PtsV2CreateBillingAgreementPost201Response > BillingAgreementsRegistrationWithHttpInfo (CreateBillingAgreement createBillingAgreement)
        {
            LogUtility logUtility = new LogUtility();

            // verify the required parameter 'createBillingAgreement' is set
            if (createBillingAgreement == null)
            {
                logger.Error("ApiException : Missing required parameter 'createBillingAgreement' when calling BillingAgreementsApi->BillingAgreementsRegistration");
                throw new ApiException(400, "Missing required parameter 'createBillingAgreement' when calling BillingAgreementsApi->BillingAgreementsRegistration");
            }

            var localVarPath = $"/pts/v2/billing-agreements";
            var localVarPathParams = new Dictionary<string, string>();
            var localVarQueryParams = new Dictionary<string, string>();
            var localVarHeaderParams = new Dictionary<string, string>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<string, string>();
            var localVarFileParams = new Dictionary<string, FileParameter>();
            object localVarPostBody = null;

            // to determine the Content-Type header
            string[] localVarHttpContentTypes = new string[] {
                "application/json;charset=utf-8"
            };
            string localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            string[] localVarHttpHeaderAccepts = new string[] {
                "application/hal+json;charset=utf-8"
            };
            string localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
            {
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);
            }

            if (createBillingAgreement != null && createBillingAgreement.GetType() != typeof(byte[]))
            {
                SdkTracker sdkTracker = new SdkTracker();
                createBillingAgreement = (CreateBillingAgreement)sdkTracker.InsertDeveloperIdTracker(createBillingAgreement, createBillingAgreement.GetType().Name, Configuration.ApiClient.Configuration.MerchantConfigDictionaryObj["runEnvironment"]);
                localVarPostBody = Configuration.ApiClient.Serialize(createBillingAgreement); // http body (model) parameter
            }
            else
            {
                localVarPostBody = createBillingAgreement; // byte array
            }

            if (logUtility.IsMaskingEnabled(logger))
            {
                logger.Debug($"HTTP Request Body :\n{logUtility.MaskSensitiveData(localVarPostBody.ToString())}");
            }
            else
            {
                logger.Debug($"HTTP Request Body :\n{localVarPostBody}");
            }


            // make the HTTP request
            RestResponse localVarResponse = (RestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.Post, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("BillingAgreementsRegistration", localVarResponse);
                if (exception != null)
                {
                    logger.Error($"Exception : {exception.Message}");
                    throw exception;
                }
            }

            return new ApiResponse<PtsV2CreateBillingAgreementPost201Response>(localVarStatusCode,
                localVarResponse.Headers.GroupBy(h => h.Name).ToDictionary(x => x.Key, x => string.Join(", ", x.Select(h => h.Value.ToString()))),
                (PtsV2CreateBillingAgreementPost201Response) Configuration.ApiClient.Deserialize(localVarResponse, typeof(PtsV2CreateBillingAgreementPost201Response))); // Return statement
        }

        /// <summary>
        /// Create a Billing Agreement #### Standing Instruction: Standing Instruction with or without Token. Transaction amount in case First payment is coming along with registration. Only 2 decimal places allowed  #### Create Mandate: You can create a mandate through the direct debit mandate flow. Possible create mandate status values:   - Pending—the create mandate request was successfully processed.   - Failed—the create mandate request was not accepted.  #### Import Mandate: In the Bacs scheme, a mandate is created with a status of active. Direct debit collections can be made against it immediately. You can import a mandate to the CyberSource database when:   - You have existing customers with signed, active mandates   - You manage mandates outside of CyberSource.  When you import an existing mandate to the CyberSource database, provide a unique value for the mandate ID or the request results in an error. If an import mandate request is not accepted, the import mandate status value is failed. 
        /// </summary>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createBillingAgreement"></param>
        /// <returns>Task of PtsV2CreateBillingAgreementPost201Response</returns>
        public async System.Threading.Tasks.Task<PtsV2CreateBillingAgreementPost201Response> BillingAgreementsRegistrationAsync (CreateBillingAgreement createBillingAgreement)
        {
            logger.Debug("CALLING API \"BillingAgreementsRegistrationAsync\" STARTED");
            this.SetStatusCode(null);
            ApiResponse<PtsV2CreateBillingAgreementPost201Response> localVarResponse = await BillingAgreementsRegistrationAsyncWithHttpInfo(createBillingAgreement);
            logger.Debug("CALLING API \"BillingAgreementsRegistrationAsync\" ENDED");
            this.SetStatusCode(localVarResponse.StatusCode);
            return localVarResponse.Data;

        }

        /// <summary>
        /// Create a Billing Agreement #### Standing Instruction: Standing Instruction with or without Token. Transaction amount in case First payment is coming along with registration. Only 2 decimal places allowed  #### Create Mandate: You can create a mandate through the direct debit mandate flow. Possible create mandate status values:   - Pending—the create mandate request was successfully processed.   - Failed—the create mandate request was not accepted.  #### Import Mandate: In the Bacs scheme, a mandate is created with a status of active. Direct debit collections can be made against it immediately. You can import a mandate to the CyberSource database when:   - You have existing customers with signed, active mandates   - You manage mandates outside of CyberSource.  When you import an existing mandate to the CyberSource database, provide a unique value for the mandate ID or the request results in an error. If an import mandate request is not accepted, the import mandate status value is failed. 
        /// </summary>
        /// <exception cref="CyberSource.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="createBillingAgreement"></param>
        /// <returns>Task of ApiResponse (PtsV2CreateBillingAgreementPost201Response)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PtsV2CreateBillingAgreementPost201Response>> BillingAgreementsRegistrationAsyncWithHttpInfo (CreateBillingAgreement createBillingAgreement)
        {
            LogUtility logUtility = new LogUtility();

            // verify the required parameter 'createBillingAgreement' is set
            if (createBillingAgreement == null)
            {
                logger.Error("ApiException : Missing required parameter 'createBillingAgreement' when calling BillingAgreementsApi->BillingAgreementsRegistration");
                throw new ApiException(400, "Missing required parameter 'createBillingAgreement' when calling BillingAgreementsApi->BillingAgreementsRegistration");
            }

            var localVarPath = $"/pts/v2/billing-agreements";
            var localVarPathParams = new Dictionary<string, string>();
            var localVarQueryParams = new Dictionary<string, string>();
            var localVarHeaderParams = new Dictionary<string, string>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<string, string>();
            var localVarFileParams = new Dictionary<string, FileParameter>();
            object localVarPostBody = null;

            // to determine the Content-Type header
            string[] localVarHttpContentTypes = new string[] {
                "application/json;charset=utf-8"
            };
            string localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            string[] localVarHttpHeaderAccepts = new string[] {
                "application/hal+json;charset=utf-8"
            };
            string localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
            {
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);
            }

            if (createBillingAgreement != null && createBillingAgreement.GetType() != typeof(byte[]))
            {
                SdkTracker sdkTracker = new SdkTracker();
                createBillingAgreement = (CreateBillingAgreement)sdkTracker.InsertDeveloperIdTracker(createBillingAgreement, createBillingAgreement.GetType().Name, Configuration.ApiClient.Configuration.MerchantConfigDictionaryObj["runEnvironment"]);
                localVarPostBody = Configuration.ApiClient.Serialize(createBillingAgreement); // http body (model) parameter
            }
            else
            {
                localVarPostBody = createBillingAgreement; // byte array
            }

            if (logUtility.IsMaskingEnabled(logger))
            {
                logger.Debug($"HTTP Request Body :\n{logUtility.MaskSensitiveData(localVarPostBody.ToString())}");
            }
            else
            {
                logger.Debug($"HTTP Request Body :\n{localVarPostBody}");
            }


            // make the HTTP request
            RestResponse localVarResponse = (RestResponse)await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.Post, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int)localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("BillingAgreementsRegistration", localVarResponse);
                if (exception != null)
                {
                    logger.Error($"Exception : {exception.Message}");
                    throw exception;
                }
            }

            return new ApiResponse<PtsV2CreateBillingAgreementPost201Response>(localVarStatusCode,
                localVarResponse.Headers.GroupBy(h => h.Name).ToDictionary(x => x.Key, x => string.Join(", ", x.Select(h => h.Value.ToString()))),
                (PtsV2CreateBillingAgreementPost201Response) Configuration.ApiClient.Deserialize(localVarResponse, typeof(PtsV2CreateBillingAgreementPost201Response))); // Return statement
        }
    }
}
